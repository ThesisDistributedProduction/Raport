% !TeX spellcheck = en_US
\chapter{Evaluation System Implementation}
The prototype in this project will consist of X virtual machines.

\section{Platform}

\section{DDS configuration}

\section{Algorithm Decentralized}\label{sec:algoDecen}

\section{Algorithm Centralized}\label{sec:algoCen}

Windows
Pro
\begin{itemize}
	\item Well known to most people (easy to get going) 
	\item 
\end{itemize}

Bad
\begin{itemize}
	\item expensive
\end{itemize}

Linux
Pro
\begin{itemize}
	\item Market leader [?] Need Source
	\item Linux Virtual server
	\item Linux Containers
	\item Open source / free
	\item More configurable with respect to scheduler (non preemptive (default), preemptive voluntary, RT ) 
	\begin{itemize}
		\item \url{http://www.linuxtopia.org/online_books/linux_kernel/kernel_configuration/re152.html}
		\item \url{http://stackoverflow.com/questions/5174955/what-is-voluntary-preemption}
		\item \url{http://lwn.net/Articles/146861/}
		\item \url{https://www.osadl.org/uploads/media/ECE-2011-09.pdf}
		\item \url{http://www.linux.com/news/featured-blogs/200-libby-clark/710319-intro-to-real-time-linux-for-embedded-developers}
								
	\end{itemize}
\end{itemize}



%user: shared
%password: windfarm

%https://forums.virtualbox.org/viewtopic.php?f=6&t=63556&start=165
 

The prototype is split int the following 3 parts:
\begin{itemize}
	\item DataSimulator
	\item HPPP component
	\item Monitor (UI component)
	\end{itemize}


\begin{tikzpicture} 
\begin{umlseqdiag} 
	\umldatabase{DB} 
	\umlmulti{DataSimulator}
	\umlmulti{Regulation Controller}
	\umlmulti{Monitor}
	\begin{umlcall}[op=getAlldata(), type=asynchron, return=0]{DB}{DataSimulator}
		\begin{umlfragment}[type=ForAll, label=Samples, inner xsep=8, fill=white!10]
			\begin{umlcall}[op=Simumlation data, type=synchron, return=setpoint]{DataSimulator}{Regulation Controller}
			
			\end{umlcall}
			\begin{umlfragment}[type=opt, fill=white!10]
				\begin{umlcall}[op=UpdateUI(), type=asynchron, return=0]{DataSimulator}{Monitor}
				\end{umlcall}
			\end{umlfragment}
		\end{umlfragment}


	\begin{umlcall}[op=saveData(), type=asynchron, return=0]{DataSimulator}{DB}
	\end{umlcall}	
	\end{umlcall}
	
	
\end{umlseqdiag} 
\end{tikzpicture}

\includegraphics{figures/metapost/ClassDiagramHPPP.1}




\tikzstyle{fact}=[rectangle, draw=none, rounded corners=1mm, fill=blue, drop shadow,
text centered, anchor=north, text=white]
\tikzstyle{state}=[circle, draw=none, fill=orange, circular drop shadow,
text centered, anchor=north, text=white]
\tikzstyle{leaf}=[circle, draw=none, fill=red, circular drop shadow,
text centered, anchor=north, text=white]
\tikzstyle{comment}=[rectangle, draw=black, fill=black!60, rounded corners, drop shadow,
anchor=west, text=white, text width=6.5cm]





\begin{tikzpicture}[node distance=0.5cm]

\node (State00) [state] {$S_{00}$};
\node (Fact01) [fact,below=of State00] {$T_{01}$} edge [<-] (State00);
\node (State01) [state,below=of Fact01] {$S_{01}$} edge [<-] (Fact01);
\node (Rule01) [comment,right=of Fact01, rectangle split, rectangle split parts=4] {
	\textbf{RULE-01}
	\nodepart{second}IF ($S_{00}$) Engine overheats
	\nodepart{third}AND ($T_{01}$) Engine itself is not the cause
	\nodepart{fourth}THEN ($S_{01}$) Cooling system is responsible for overheat
};

\begin{pgfonlayer}{background}
\path (State00.west |- State00.north)+(-0.4,0.4) node (a) {};
\path (Rule01.east |- State01.south)+(0.4,-0.4) node (b) {};
\path [fill=yellow!40,rounded corners, draw=black!50, dashed] (a) rectangle (b); 
\end{pgfonlayer}
\end{tikzpicture}

\section{Graphical Interface}
In order to visualize the system a graphical user interface has been constructed using Matlab, Simulink and DDS Blockset for Simulink.
These tools combined allows the creation of a Simulink model which taps into the communication of the DDS framework.
The data collected from via the Simulink model can then be transferred to Matlab for further processing or visualization.

The main objective of the graphical interface is to visualize what messages is currently flowing in the system but almost as important is the ability to collect data for further analysis.
Matlab is a powerful tool for anlysis and having the data transferred live from the DDS framework to matlab allows for both live as well as in depth analysis on a dataset collected during an experiment.

\subsection{DDS Blockset for Simulink}
RTI has created a Blockset for Simulink allowing a Simulink model to interact with the DDS Participant and other entities in a DDS enabled network.
The blockset consists of a toolbox containing 6 blocks. Common for all blocks except the DDS Time block is that they can be configured with a default or custom Quality of Service profile as well as a sample time. The Quality of Service profile must match the profile used in the network you want to participate in. The sample time is related to the Simulink model and specifies the timeinterval between samples.

\paragraph{The DomainParticipant block} is the equivalent to the DomainParticipant entity in DDS. This block allows for configuration of the DomainID which links the DomainParticipant to a specific DDS domain.

\paragraph{The Publisher/Subscriber block} can be configured as either a Publisher or a Subscriber and will act as either based on the chosen configuration.

\paragraph{The DataWriter block} is the equivalent to the DataWriter entity in DDS. This block can write data to a topic in DDS. The DataWriter block must be configured with the name of the Topic as well as the name of the Topic Type created by the Simulink Bus that is input to the DataWriter.

\paragraph{The DataReader block} is the equivalent to the DataReader entity in DDS. This block can read data from a topic in DDS. The DataReader block must be configured with the name of the Topic as well as the name of the Topic Type created by the Simulink Bus that is input to the DataReader. The DataReader block can also be configured to either use Read() or Take() for obtaining the DDS data. The Read() command will leave the data in DDS memory, the Take() command will remove the data from DDS memory. The DataReader block is able to either poll DDS for data or wait for data until data is ready or a timeout occurs.

\paragraph{The DDSTarget block} is controls code generated for the DDS blocks in the Simulink model. It is possible to configure which version of DDS code will be generated for, either RTI Connext DDS(default), or RTI Connext Micro DDS. The type system can be configured to either static or dynamic as well as the discovery mode.

\paragraph{The Time block} can return the current time from DDS output in seconds and nanoseconds.